SPLICE Modules Versioning Proposal

Purpose

A simple and reliable scheme for versioning Nextflow modules in the splice-nf-modules monorepo. It must be easy to teach, audit, and reproduce. It should work well with git subtree and offline environments.

Where we are today
	•	Current repo without explicit versioning of module wrappers.
	•	Tools and tasks live under modules/<namespace>/<tool>/<task>.
	•	Each module has main.nf, meta.yml, environment.yml, and tests.

Where we want to get to
	•	Tool version recorded in the folder path when it affects the runtime environment.
	•	Wrapper version recorded in files and in a git tag. No extra numbering scheme beyond SemVer.
	•	Pipelines pull an exact wrapper release by tag with git subtree.
	•	CI remains light. It runs tests and publishes a badge. No auto bumping in the first phase.

Principles
	1.	Reproducibility comes first. A user must be able to pull exactly what they used before.
	2.	Human readable and low ceremony. Changes are visible in the folder tree and in the tag name.
	3.	Manual control for pipelines. Updates are pulled on purpose.
	4.	Keep it monorepo for now. Revisit if scale or governance needs change.

Folder layout and version locations

Folder path

modules/<namespace>/<tool>/<task>/<tool_version?>/

	•	Use the tool version folder only if the runtime environment changes. Examples include a new binary, new container tag, or pinned conda version change. If the wrapper changes without changing the tool environment, stay in the same folder.

Inside the module folder

VERSION            # wrapper version such as 1.4.0
meta.yml           # includes tool name and tool version and wrapper_version: 1.4.0
CHANGELOG.md       # short human notes

Wrapper versioning rules
	•	Semantic Versioning
	•	Patch and minor for improvements or fixes that do not change inputs or outputs
	•	Major for any change that will break a pipeline that consumes the module
	•	No separate IO contract number. The major version is the signal for a break

Tagging scheme

Each release of a wrapper is marked by a tag that is unique per tool version.

Tag format

<namespace>-<tool>-<task>@tool-<tool_version>_wrap-<wrapper_version>

Examples

cruksi-fastp-trim@tool-0.23.4_wrap-1.4.0
cruksi-fastp-trim@tool-0.23.4_wrap-2.0.0    # breaking change
cruksi-fastp-trim@tool-0.24.0_wrap-1.0.0    # new tool version folder

Tags are simple labels that point to a commit. GitHub shows code at that tag and allows a download.

Release flow for maintainers
	1.	Edit code in the module folder
	2.	Update VERSION and wrapper_version in meta.yml
	3.	Add a short entry in CHANGELOG.md
	4.	Commit
	5.	Create and push tag

Helper commands

MOD=modules/cruksi/fastp/trim/0.23.4
WRAP=$(cat $MOD/VERSION)
TAG="cruksi-fastp-trim@tool-0.23.4_wrap-$WRAP"

git add $MOD
git commit -m "cruksi/fastp/trim 0.23.4 wrapper $WRAP"
git tag -a "$TAG" -m "cruksi/fastp/trim 0.23.4 wrapper $WRAP"
git push origin main --tags

How pipeline repos consume modules

Pipelines keep full control and pull a specific tag.

First import

git subtree add \
  --prefix modules/cruksi/fastp/trim/0.23.4 \
  https://github.com/Beatson-CompBio/splice-nf-modules.git \
  cruksi-fastp-trim@tool-0.23.4_wrap-1.4.0 \
  --squash

Update to a new wrapper

git subtree pull \
  --prefix modules/cruksi/fastp/trim/0.23.4 \
  https://github.com/Beatson-CompBio/splice-nf-modules.git \
  cruksi-fastp-trim@tool-0.23.4_wrap-1.6.0 \
  --squash

Revert to an earlier wrapper

git subtree pull \
  --prefix modules/cruksi/fastp/trim/0.23.4 \
  https://github.com/Beatson-CompBio/splice-nf-modules.git \
  cruksi-fastp-trim@tool-0.23.4_wrap-1.4.0 \
  --squash

Documentation aids

Each module page should open with a version box.

Version box template

Module    cruksi/fastp/trim
Tool     fastp 0.23.4
Wrapper  1.4.0
Tag      cruksi-fastp-trim@tool-0.23.4_wrap-1.4.0
Path     modules/cruksi/fastp/trim/0.23.4

Add a simple repo level index at docs/MODULES.md generated by a small script that finds main.nf files and reads meta.yml and VERSION.

CI in the near term
	•	One workflow that installs Nextflow and nf test
	•	Run all discovered *.test files or only those touched in the pull request
	•	Publish a badge in README.md
	•	Do not modify files in the repo

Why this choice
	•	Low maintenance
	•	Clear signal of test health
	•	No hidden automation

Notifications to pipelines

Keep it manual for now. Teams can watch releases on GitHub. Later we can add a small notifier that opens an issue in subscriber repos when a new module tag appears. No auto merge.

Migration plan from current repo
	1.	Do not change existing folder names yet
	2.	For modules that already pin a tool environment create the tool version folder on the next edit. Example modules/splice/samtools/sort/1.19
	3.	Start adding VERSION, meta.yml wrapper_version, and CHANGELOG.md for each module as it changes
	4.	Begin tagging wrapper releases as described above
	5.	Add docs/MODULES.md and a small generator script
	6.	Add a light nf test workflow and the README badge

Future options
	•	Add a make target to create tags and do basic validation
	•	Add a doc page that lists tags per module using git tag --list
	•	Introduce an optional subscribers file for release notifications
	•	Consider a split of the repo if governance or access needs diverge across namespaces

FAQ

Can a user view older wrappers in the browser  Yes. Go to the Tags tab and click the relevant tag. The file tree shows that snapshot. The Download ZIP link provides an archive.

What if a wrapper breaks user code but the tool version stays the same  Bump the wrapper major version. Keep the same folder. Release a new tag.

What if the tool version changes but the wrapper logic is the same  Create a new tool version folder. Start wrapper at 1.0.0 for that folder.

Why not add more numbering  Fewer numbers are easier to teach and to remember. Major version already carries the signal for breaking changes.
